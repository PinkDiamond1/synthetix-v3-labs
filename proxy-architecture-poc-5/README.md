## "Router Proxy" POC #5

This proof of concept combines a single universal proxy with a hardcoded lookup table, or router, which maps function selectors to the implementation contract where such selector is implemented.

For a simpler, easier to understand, but more primitive version of this experiment, see POC #4.

The router contract is dynamically generated by looking at the existing modules, resulting in something like:

```
// Lookup table: Function selector => implementation contract
bytes4 sig4 = msg.sig;
address implementation;
assembly {
    let sig32 := shr(224, sig4)

    function findImplementation(sig) -> result {
        let SettingsModule := 0x1D8D70AD07C8E7E442AD78E4AC0A16f958Eba7F0
        let UpgradeModule := 0xA9e6Bfa2BF53dE88FEb19761D9b2eE2e821bF1Bf
        let OwnerModule := 0x1E3b98102e19D3a164d239BdD190913C2F02E756

        switch sig
        case 0x13af4035 { result := OwnerModule } // OwnerModule.setOwner()
        case 0x3659cfe6 { result := UpgradeModule } // UpgradeModule.upgradeTo()
        case 0x38536275 { result := SettingsModule } // SettingsModule.setMinCollateralRatio()
        case 0x4c8f35ab { result := SettingsModule } // SettingsModule.getMinCollateralRatio()
        case 0x893d20e8 { result := OwnerModule } // OwnerModule.getOwner()
        case 0xaaf10f42 { result := UpgradeModule } // UpgradeModule.getImplementation()
        leave
    }

    implementation := findImplementation(sig32)
}
```

In theory, the router could handle a large amount of selectors, but if the amount increases, selectors at the end of the list would have more gas overhead than the ones at the top of the list. Thus, the generator uses a binary search instead of a linear one, ensuring that switch statements in the router contain at most 7 elements.

![Diagram](imgs/diag.png)

### Communication between modules

Any module can easily access any other module by casting itself to the other module, e.g:

```
contract IssuerModule {
    function getValueViaExchanger() public view returns (string memory) {
        return ExchangerModule(address(this)).getValue();
    }
}
```

This is possible because all modules have access to the main proxy's storage, which removes the need of an AddressResolver or SystemSettings contract. Given that every module also has access to every other module, this pattern allows for extreme modularity and small smart contract deployment sizes, which are needed properties of the Synthetix v3 system in Optimism.

### Storage namespaces

To avoid storage collisions, modules must not declare in-contract variables, but instead access a storage namespace. This deviates signifficanlty from regular Solidity code style, but should not introduce too much complexity for developers.

```
bytes32 constant GLOBAL_STORAGE_POSITION = keccak256("io.synthetix.global");

struct GlobalStorage {
    address owner;
    string version;
}

function globalStorage() internal pure returns (GlobalStorage storage store) {
    bytes32 position = GLOBAL_STORAGE_POSITION;

    assembly {
        store.slot := position
    }
}
```

Any number of additional namespaces can be declared, i.e.

```
...
bytes32 constant ISSUANCE_STORAGE_POSITION = keccak256("io.synthetix.issuance");
...
bytes32 constant COLLATERAL_STORAGE_POSITION = keccak256("io.synthetix.collateral");
...
```

The only caveat is that storage within a namespace is append only. Properties within a namespace cannot be renamed or reordered, and new properties can only be appended to a struct.

### Mixins

Additionally, mixins, which are not modules, can be inherited by any module for accessing common functionality.

```
contract OwnerMixin is GlobalStorageAccessor {
    modifier onlyOwner {
        require(msg.sender == globalStorage().owner, "Only owner allowed");
        _;
    }
}
```

Thus, the general architecture can be categorized as follows:

* Storage namespaces: Provide a storage structure for a particular functionality. E.g. GlobalStorage, or IssuerStorage.
* Modules: Implement a specific compartimentalized feature of the system, accessing one or more storage namespaces, and requiring an implementation contract to be deployed and hardcoded into the main proxy.
* Mixins: Intended to be inherited by modules, can access any storage namespace, add functions and modifiers to a module, and are not intended to be deployed as an implementation contract. E.g. OwnerMixin.
* Libraries: Provide common functionality to modules, without inheriting. E.g. SafeDecimalMath.

### Development considerations

Developers will need to:
* Only use storage via namespaces
* Always append variables to a namespace storage struct (enforced by tooling)
* All functions in modules need to be unique (enforced by tooling)

The lookup table in the main proxy's implementation is generated in order to reduce a bit of gas, but mainly for removing any kind of diamond proxy complexity from the Solidity code.

### Testing this experiment locally

1. Start local node with `npx hardhat node`
2. Deploy the system with `npx hardhat run scripts/deploy.js`
3. Run tests with `npx hardhat test`

Additionally, step 2 can be broken up into these commands:
* Clear local deployment data with `npx hardhat run scripts/clear-deployments.js`
* Deploy system moduels with `npx hardhat run scripts/deploy-modules.js`
* Generate main proxy router with `npx hardhat run scripts/generate-proxy.js`
* Deploy main proxy router `npx hardhat run scripts/deploy-proxy.js`

### Differences with POC #4

This experiment continues where POC #4 left of.

1. Cheaper proxying

Instead of using OpenZeppelin transparent proxies, UUPS proxies are used (Universal Upgradeable Proxy Standard). See https://eips.ethereum.org/EIPS/eip-1822

Transparent proxies have a forwarding overhead of around ~3000 gas, while UUPS only add nearly half as much, ~1600 gas. This, combined with the router adds an overhead of ~2600 gas, is less than a system only using transparent proxies.

Of course, this could increase with a larger router, which could be later optimized with lower level code generation and/or implementing a binary search in the routing.

Universal proxies achieve this optimization by placing the upgradeability management code in the implementation, instead of the proxy. Thus, it avoids checking if the caller is the admin on every single interaction with the system. The downside is that an incorrect implementation could brick the proxy. Fran and I believe, however, that this problem could be mitigated by checks on the upgrade logic and good tooling.

2. Optimized router

Even though the router is pretty efficient, it quickly loses efficiency as the number of selectors increases. This is because the bytecode produced by Solidity for simple "if" matching is quite poor.

This POC uses Yul for router code, and implements binary instead of linear search for the actual routing.

### Open questions

TBD
