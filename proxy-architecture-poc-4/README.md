## Proxy POC #4

This proof of concept combines Open Zeppelin transparent proxies with diamond proxies.

The main Synthetix contract is a transparent proxy whose implementation is dynamically generated by tooling.
A rudimentary generator can be run in this poc with `npx hardhat run scripts/generate.js`.

The generated Synthetix implementation contains a hardcoded lookup table from `selector` to `implementation`, allowing the proxy to perform delegatecall to multiple implementations or modules.

E.g.
```
fallback() external {
    // Function selector to implementation contract lookup table
    address implementation;
    if (
      msg.sig == 0x430fe9c1 ||
      msg.sig == 0x0d8e6e2c ||
      msg.sig == 0x03c0a389 ||
      msg.sig == 0x788bc78c
    ) implementation = 0xD2c7D79ED97DfBE878a164F261549ddEeA4aD8a6;
    else if (
      msg.sig == 0xd72e0705 ||
      msg.sig == 0x10916f3b ||
      msg.sig == 0xe6dbd15d
    ) implementation = 0x3Bb4145F86b1F6519aCBf4438A808E9Bf6C5cC8A;
    else if (
      msg.sig == 0xe017bb0d
    ) implementation = 0x8B399a32deCa6CC56A21CF6c092D9DF05211CF72;
    require(implementation != address(0), "Selector not registered in any module");

    // Delegatecall forwarder
    assembly {
        calldatacopy(0, 0, calldatasize())
        let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)
        returndatacopy(0, 0, returndatasize())
        switch result
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
    }
}
```

Any module can easily access any other module by casting itself to the other module, e.g:

```
contract IssuerModule {
    function getValueViaExchanger() public view returns (string memory) {
        return ExchangerModule(address(this)).getValue();
    }
}
```

This is possible because all modules have access to the main proxy's storage, which removes the need of an AddressResolver or SystemSettings contract. Given that every module also has access to every other module, this pattern allows for extreme modularity and small smart contract deployment sizes, which are needed properties of the Synthetix v3 system in Optimism.

To avoid storage collisions, modules must not declare in-contract variables, but instead access a storage namespace. This deviates signifficanlty from regular Solidity code style, but should not introduce too much complexity for developers.

Developers will need to:
* Only use storage via namespaces
* Always append variables to a namespace storage struct (enforced by tooling)
* All functions in modules need to be unique (enforced by tooling)

The lookup table in the main proxy's implementation is generated in order to reduce a bit of gas, but mainly for removing any kind of diamond proxy complexity from the Solidity code.

#### Deploying an instance

First, specify PROVIDER_URL and MNEMONIC in a .env file. Then, run `npx hardhat run scripts/deploy.js --network kovan`

Sample output:
```
Compiling 1 file with 0.7.3
Compilation finished successfully
Connected to Synthetix proxy at 0xd60999588D2DC8826325224e1A17D6090c5d5f38
Upgrading Synthetix proxy implementation to 0xf73fd96768E4B353db901D294f19F7B8280b2cd8
Connected to ExchangerModule at 0x48D79c516C2494AcDCfC059615964E207Da81b0d
  > Selectors:
    * getValue: 0x20965255
    * setValue: 0x93a09352
Connected to IssuerModule at 0xF80d27Bd332301ee5AbEeEAad419360be816f5fC
  > Selectors:
    * getValueViaExchanger: 0x43ce657d
GlobalStorage.someValue via ExchangerModule: 42
GlobalStorage.someValue via IssuerModule: 42
```
