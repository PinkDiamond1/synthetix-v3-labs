## Proxy POC #4

This proof of concept combines Open Zeppelin transparent proxies with diamond proxies.

The main Synthetix contract is a transparent proxy whose implementation is dynamically generated by tooling.

The generated Synthetix implementation contains a hardcoded lookup table from `selector` to `implementation`, allowing the proxy to perform delegatecall to multiple implementations or modules.

E.g.
```
fallback() external {
    // Function selector to implementation contract lookup table
    address implementation;
    if (
      msg.sig == 0x430fe9c1 ||
      msg.sig == 0x0d8e6e2c ||
      msg.sig == 0x03c0a389 ||
      msg.sig == 0x788bc78c
    ) implementation = 0xD2c7D79ED97DfBE878a164F261549ddEeA4aD8a6;
    else if (
      msg.sig == 0xd72e0705 ||
      msg.sig == 0x10916f3b ||
      msg.sig == 0xe6dbd15d
    ) implementation = 0x3Bb4145F86b1F6519aCBf4438A808E9Bf6C5cC8A;
    else if (
      msg.sig == 0xe017bb0d
    ) implementation = 0x8B399a32deCa6CC56A21CF6c092D9DF05211CF72;
    require(implementation != address(0), "Selector not registered in any module");

    // Delegatecall forwarder
    assembly {
        calldatacopy(0, 0, calldatasize())
        let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)
        returndatacopy(0, 0, returndatasize())
        switch result
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
    }
}
```

Any module can easily access any other module by casting itself to the other module, e.g:

```
contract IssuerModule {
    function getValueViaExchanger() public view returns (string memory) {
        return ExchangerModule(address(this)).getValue();
    }
}
```

This is possible because all modules have access to the main proxy's storage, which removes the need of an AddressResolver or SystemSettings contract. Given that every module also has access to every other module, this pattern allows for extreme modularity and small smart contract deployment sizes, which are needed properties of the Synthetix v3 system in Optimism.

To avoid storage collisions, modules must not declare in-contract variables, but instead access a storage namespace. This deviates signifficanlty from regular Solidity code style, but should not introduce too much complexity for developers.

Developers will need to:
* Only use storage via namespaces
* Always append variables to a namespace storage struct (enforced by tooling)
* All functions in modules need to be unique (enforced by tooling)

The lookup table in the main proxy's implementation is generated in order to reduce a bit of gas, but mainly for removing any kind of diamond proxy complexity from the Solidity code.

#### Testing locally

1. Start local node with `npx hardhat node`
2. Deploy the system with `npx hardhat run scripts/deploy.js`
3. Run tests with `npx hardhat test`

Additionally, step 2 can be broken up to these commands:
* Clear local deployment data with `npx hardhat run scripts/clear-deployments.js`
* Deploy system moduels with `npx hardhat run scripts/deploy-modules.js`
* Generate main proxy router with `npx hardhat run scripts/generate-proxy.js`
